# IEEE SusTech Student Branch - Project Team - Back End

Here I will upload my progress on learning Django, following [this tutorial](https://docs.djangoproject.com/en/4.0/intro/tutorial01/) on a set schedule . I am using Windows 10, so all code written below is specifically windows-compatible

### Installation

Install [Python](https://python.org)

Use the package manager [pip](https://pip.pypa.io/en/stable/) to install [Django](https://docs.djangoproject.com/en/4.0/intro/install/)

```bash
py -m pip install Django
```

Go to a directory you want your project files to reside in.

Create a [virtual environment](https://docs.python.org/3/library/venv.html)

```bash
py -m venv NameOfVirtualEnvironment
```
Install Django again within the virtual environment, and upgrade pip if you need to

## Week One - The MVT design pattern and my first view:
### polls/urls.py 
```python
from django.urls import path
from . import views

urlpatterns = [
    path('', views.index, name='home'),
]
```
### polls/views.py
```python
from django.shortcuts import render
from django.http import HttpResponse

def index(req):
    return HttpResponse('Hello Django, this is the index page of the polls app')
```
### mysite/urls.py
```python
from django.contrib import admin
from django.urls import path, include  # Imported the include function

urlpatterns = [
    path('admin/', admin.site.urls),
    path('polls', include('polls.urls')),
    # Used the include function here to route to polls
]
```
## Week Two - Database setup and working with models
First and foremost, run the migrate command to start working with the database (in this case the already existing db.sqlite3)
```bash
py manage.py migrate
```
Connect your app to the main backend, so I added the polls app to mysite.
### mysite/settings.py
```python
# Application definition

INSTALLED_APPS = [
    'polls.apps.PollsConfig',  # added
    'django.contrib.admin',
    'django.contrib.auth',
    'django.contrib.contenttypes',
    'django.contrib.sessions',
    'django.contrib.messages',
    'django.contrib.staticfiles',
]
```
Now you can customize your models, to create database tables  with a specific underlying logic and model

### polls/models.py
```python
import datetime

from django.db import models
from django.utils import timezone


class Question(models.Model):
    q_txt = models.CharField(max_length=200)
    pub_date = models.DateTimeField('date published')
    # Human friendly name ^

    def __str__(self):
        return self.q_txt

    def was_published(self):
        return self.pub_date >= timezone.now() - datetime.timedelta(days=1)


class Choice(models.Model):
    q = models.ForeignKey(Question, on_delete=models.CASCADE)
    choice_txt = models.CharField(max_length=200)
    votes = models.IntegerField(default=0)

    def __str__(self):
        return self.choice_txt

# Create your models here.
```
### polls/admin.py
```python
from django.contrib import admin
from .models import Question

admin.site.register(Question)

# Register your models here.
```
Then run the following on the terminal
```bash
py manage.py makemigrations polls
```
This ^ will genereate a new folder within the polls directory, and create a python file called 0001_initial.py
The fill will look something like this
### polls/migrations/0001_initial.py
```python
# Generated by Django 4.0.4 on 2022-04-14 17:36

from django.db import migrations, models
import django.db.models.deletion


class Migration(migrations.Migration):

    initial = True

    dependencies = [
    ]

    operations = [
        migrations.CreateModel(
            name='Question',
            fields=[
                ('id', models.BigAutoField(auto_created=True, primary_key=True, serialize=False, verbose_name='ID')),
                ('q_txt', models.CharField(max_length=200)),
                ('pub_date', models.DateTimeField(verbose_name='date published')),
            ],
        ),
        migrations.CreateModel(
            name='Choice',
            fields=[
                ('id', models.BigAutoField(auto_created=True, primary_key=True, serialize=False, verbose_name='ID')),
                ('choice_txt', models.CharField(max_length=200)),
                ('votes', models.IntegerField(default=0)),
                ('q', models.ForeignKey(on_delete=django.db.models.deletion.CASCADE, to='polls.question')),
            ],
        ),
    ]

```
From here, you could immediately run the migrate command and configure your database to accommodate the change in your models
However, if you were interested in seeing what SQL would run on the database, you could run sqlmigrate
```bash
py manage.py sqlmigrate polls 0001
```
This will show you some SQL in the terminal that looks something like this (just less formatted)
```sql
BEGIN;
--
-- Create model Question
--
CREATE TABLE "polls_question" (
    "id" serial NOT NULL PRIMARY KEY,
    "question_text" varchar(200) NOT NULL,
    "pub_date" timestamp with time zone NOT NULL
);
--
-- Create model Choice
--
CREATE TABLE "polls_choice" (
    "id" serial NOT NULL PRIMARY KEY,
    "choice_text" varchar(200) NOT NULL,
    "votes" integer NOT NULL,
    "question_id" integer NOT NULL
);
ALTER TABLE "polls_choice"
  ADD CONSTRAINT "polls_choice_question_id_c5b4b260_fk_polls_question_id"
    FOREIGN KEY ("question_id")
    REFERENCES "polls_question" ("id")
    DEFERRABLE INITIALLY DEFERRED;
CREATE INDEX "polls_choice_question_id_c5b4b260" ON "polls_choice" ("question_id");

COMMIT;
```
Then you can migrate if you think this looks good, and either interact with the API using the shell or the GUI
For using the python shell, you run
```bash
py manage.py shell
```
To use the GUI, you use the [django admin](https://docs.djangoproject.com/en/4.0/intro/tutorial02/#introducing-the-django-admin)

## Week Four - Handling URLs, Views and Templates
When we naviagate a website, we navigate the folders and files that the server allows us to see on the client-side. We can tell where we are based on the URL in our browser; something like "github.com/ib-bib" tells us that we navigated to the ib-bib 'directory' within GitHub.
We handle showing patterns like these in our URLs files. The example below shows a specific pattern and a few general patterns to handle
### polls/urls.py
```python
from django.urls import path
from . import views

app_name = 'polls'
urlpatterns = [
    path('', views.index, name='index'),
    path('<int:question_id>/', views.detail, name='detail'),
    path('<int:question_id>/results/', views.results, name='results'),
    path('<int:question_id>/vote/', views.vote, name='vote'),
]
```
Notice the use of 'int' there, that states that the url pattern will contain an integer which we will refer to as 'question_id'. This is very useful to be more specific in our approach to stating what are acceptable url patterns.

The 'views' that are imported at the top, are the functions that allow us to respond to these url patterns in the browser. That is, what we show the client as a result of the url pattern being selected on their browser
### polls/views.py
```python
from django.http import HttpResponse
from .models import Question
from django.shortcuts import render, get_object_or_404


def index(request):
    latest_questions_list = Question.objects.order_by('-pub_date')[:5]
    context = {'latest_questions_list': latest_questions_list, }
    return render(request, 'polls/index.html', context)


def detail(request, question_id):
    question = get_object_or_404(Question, pk=question_id)
    return render(request, 'polls/detail.html', {'question': question})
    

def results(request, question_id):
    response = "You're looking at the results of question %s."
    return HttpResponse(response % question_id)


def vote(request, question_id):
    return HttpResponse("You're voting on question %s." % question_id)
```
We notice some functions have an 'HttpResponse' as a response to the URL request. This creates a very very simple bare-bones webpage that just contains simple text that is defined in the function. In other functions there is a 'render' function that is served as a response, which returns a legitimately designed webpage, that we can customize. Moreover, we can inject some back-end code into that webpage to make it behave a certain way or display certain things, in a manner informed by data on the back-end. Such a webpage is labelled a 'template' in this context, as it's an abstract representation of what 'will be' rendered and displayed on the webpage and it's not written in traditional HTML.

Here is an example of such templates, notice the lines with curly braces and percentage signs
### polls/templates/polls/detail.html
```html
<!DOCTYPE html>
<html lang="en">
	<head>
		<meta charset="UTF-8" />
		<meta http-equiv="X-UA-Compatible" content="IE=edge" />
		<meta name="viewport" content="width=device-width, initial-scale=1.0" />
		<title>Detail</title>
	</head>
	<body>
		<h1>{{question.q_txt}}</h1>
		<ul>
			{% for choice in question.choice_set.all %} 
            {% comment %} all is interpreted as a method call () {% endcomment %}
			<li>{{choice.choice_txt}}</li>
			{% endfor %}
		</ul>
	</body>
</html>
```
We can notice the use of a for loop there, and a command to be executed at each iteration through the loop. This is more akin to programming than web design, and it allows us to abstractly (and dynamically) render however many ```<li>``` items as we need within that ```<ul>``` element. Moreover it's immediately informed by the back-end, rather than being fetched through something like asynchronous javascript.

## Week Five - Django Forms and Generic Views
Due to some experience with PHP in university courses, I was somewhat familiar with form handling. We have an html form with an ```action``` attribute, and the value of that attribute is the file that handles the form. Given that you're uploading data to the server via the form, you are making an HTTP POST request, to create new data in the database. This will look something like this in Django HTML
```html
<form action="{% url 'polls:vote' question.id %}" method="post">
```
An important thing to be aware of when handling data between front-end and back-end, is ways in which malcious intent could exploit this connection. 
For example, when handling forms, the ```action``` attribute can be changed by a third-party to execute undesired functions. 
This is called a "Cross Site Resource Forgery" attack, commonly referred to by the acronym 'CSRF'.
A way to protect against this is to generate a secret token, that the server recognizes as unique to a user in a specific session dealing with the form template.
After the user submits the form, another token will be produced. If the action attribute is changed, the second token will not match the previous token. That is how we recognize a CSRF attack. 
To generate the token in Django, we simply write
```html
<form action="{% url 'polls:vote' question.id %}" method="post">
+	{% csrf_token %}
```
This csrf_token is a stand-in for something that would usually look something like
```html
<input type="hidden" name="CSRFToken" value="OWY4NmQwODE4ODRjN2Q2NTlhMmZlYWEwYzU1YWQwMTVhM2JmNGYxYjJiMGI4MjJjZDE1ZDZMGYwMGEwOA==">
```

Next, we have form validation. The most basic kind of error in a form is the submission of an empty form; i.e a POST request with no data at all.
In this particular tutorial, the form we're handling here is composed of a radio button choice.
### polls/templates/polls/detail.html
```html
<form action="{% url 'polls:vote' question.id %}" method="post">
	{% csrf_token %}
	<fieldset>
		<legend><h1>{{ question.q_txt }}</h1></legend>
		{% if error_message %}
			<p><strong>{{ error_message }}</strong></p>
		{% endif %}
		{% for choice in question.choice_set.all %}
			<input
				type="radio"
				name="choice"
				id="choice{{ forloop.counter }}"
				value="{{ choice.id }}"
			/>
			<label for="choice{{ forloop.counter }}">
				{{ choice.choice_txt }}
			</label>
			<br />
		{% endfor %}
	</fieldset>
	<input type="submit" value="Vote" />
</form>
```
The ```name``` attribute is what allows us to identify the data/datum in our back-end.
We then handle the potential empty form submission by using a ```try``` clause, that surrounds the data/datum.
### polls/views.py
```python
def vote(request, question_id):
    question = get_object_or_404(Question, pk=question_id)
    try:
        selected_choice = question.choice_set.get(pk=request.POST['choice'])
    except (KeyError, Choice.DoesNotExist):
        # ...
```
Similarly to the associative array ```$_POST[]``` in PHP, we have a python dictionary called ```POST[]``` in Django. 

To minimize verbosity and redundancy in our views, we should opt to use class-based views (a.k.a [generic views](https://docs.djangoproject.com/en/4.0/topics/class-based-views/))
We first have to change our url patterns, to utilize the class-based approach better. This approach allows us to operate at a higher level of abstraction
### polls/urls.py
```python
urlpatterns = [
    path('', views.IndexView.as_view(), name='index'),
    path('<int:pk>/', views.DetailView.as_view(), name='detail'),
    path('<int:pk>/results/', views.ResultsView.as_view(), name='results'),
    path('<int:question_id>/vote/', views.vote, name='vote'),
]
```
We previously had a specific 'question_id' variable here, but now we have a more general 'pk' or 'Primary Key' variable.
The generic views won't have the variable pre-defined, but will be defined later on down the line. This is a very helpful level of abstraction.
Now we need to change our actual views themseleves
### polls/views.html
```python
from django.views import generic
from .models import Choice, Question


class IndexView(generic.ListView):
    template_name = 'polls/index.html'
    context_object_name = 'latest_questions_list'

    def get_queryset(self):
        return Question.objects.order_by('-pub_date')[:5]


class DetailView(generic.DetailView):
    model = Question
    template_name = 'polls/detail.html'


class ResultsView(generic.DetailView):
    model = Question
    template_name = 'polls/results.html'
```
If nothing, this just looks a lot cleaner and easier to digest. 
The ```ListView``` and the ```DetailView``` classes do all the work under the hood here. 
Instead of writing the python code ourselves, we just have the ```ListView``` generic view display a list of objects on a specific template. 
We override the ```get_queryset(self)``` method here to restrict the number of objects displayed.
The ```DetailView``` generic view expects a 'pk' argument, which is the main reason we pass 'pk' to the generic views in the urlpatterns.
By default, the ```DetailView``` uses a template called ```<app name>/<model name>_detail.html```.
The ```ListView``` uses ```<app name>/<model name>_list.html```.
We override both of these by declaring a ```template_name variable``` in our code.
