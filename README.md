# IEEE SusTech Student Branch - Project Team - Back End

Here I will upload my progress on learning Django, following this [tutorial](https://docs.djangoproject.com/en/4.0/intro/tutorial01/) on a set schedule . I am using Windows 10, so all code written below is specifically windows-compatible

### Installation

Install [Python](https://python.org)

Use the package manager [pip](https://pip.pypa.io/en/stable/) to install [Django](https://docs.djangoproject.com/en/4.0/intro/install/)

```bash
py -m pip install Django
```

Go to a directory you want your project files to reside in.

Create a [virtual environment](https://docs.python.org/3/library/venv.html)

```bash
py -m venv NameOfVirtualEnvironment
```
Install Django again within the virtual environment, and upgrade pip if you need to

## Week One - The MVT design pattern and my first view:
### polls/urls.py 
```python
from django.urls import path
from . import views

urlpatterns = [
    path('', views.index, name='home'),
]
```
### polls/views.py
```python
from django.shortcuts import render
from django.http import HttpResponse

def index(req):
    return HttpResponse('Hello Django, this is the index page of the polls app')
```
### mysite/urls.py
```python
from django.contrib import admin
from django.urls import path, include  # Imported the include function

urlpatterns = [
    path('admin/', admin.site.urls),
    path('polls', include('polls.urls')),
    # Used the include function here to route to polls
]
```
## Week Two - Database setup and working with models
First and foremost, run the migrate command to start working with the database (in this case the already existing db.sqlite3)
```bash
py manage.py migrate
```
Connect your app to the main backend, so I added the polls app to mysite.
### mysite/settings.py
```python
# Application definition

INSTALLED_APPS = [
    'polls.apps.PollsConfig',  # added
    'django.contrib.admin',
    'django.contrib.auth',
    'django.contrib.contenttypes',
    'django.contrib.sessions',
    'django.contrib.messages',
    'django.contrib.staticfiles',
]
```
Now you can customize your models, to create database tables  with a specific underlying logic and model

### polls/models.py
```python
import datetime

from django.db import models
from django.utils import timezone


class Question(models.Model):
    q_txt = models.CharField(max_length=200)
    pub_date = models.DateTimeField('date published')
    # Human friendly name ^

    def __str__(self):
        return self.q_txt

    def was_published(self):
        return self.pub_date >= timezone.now() - datetime.timedelta(days=1)


class Choice(models.Model):
    q = models.ForeignKey(Question, on_delete=models.CASCADE)
    choice_txt = models.CharField(max_length=200)
    votes = models.IntegerField(default=0)

    def __str__(self):
        return self.choice_txt

# Create your models here.
```
### polls/admin.py
```python
from django.contrib import admin
from .models import Question

admin.site.register(Question)

# Register your models here.
```
Then run the following on the terminal
```bash
py manage.py makemigrations polls
```
This ^ will genereate a new folder within the polls directory, and create a python file called 0001_initial.py
The fill will look something like this
### polls/migrations/0001_initial.py
```python
# Generated by Django 4.0.4 on 2022-04-14 17:36

from django.db import migrations, models
import django.db.models.deletion


class Migration(migrations.Migration):

    initial = True

    dependencies = [
    ]

    operations = [
        migrations.CreateModel(
            name='Question',
            fields=[
                ('id', models.BigAutoField(auto_created=True, primary_key=True, serialize=False, verbose_name='ID')),
                ('q_txt', models.CharField(max_length=200)),
                ('pub_date', models.DateTimeField(verbose_name='date published')),
            ],
        ),
        migrations.CreateModel(
            name='Choice',
            fields=[
                ('id', models.BigAutoField(auto_created=True, primary_key=True, serialize=False, verbose_name='ID')),
                ('choice_txt', models.CharField(max_length=200)),
                ('votes', models.IntegerField(default=0)),
                ('q', models.ForeignKey(on_delete=django.db.models.deletion.CASCADE, to='polls.question')),
            ],
        ),
    ]

```
From here, you could immediately run the migrate command and configure your database to accommodate the change in your models
However, if you were interested in seeing what SQL would run on the database, you could run sqlmigrate
```bash
py manage.py sqlmigrate polls 0001
```
This will show you some SQL in the terminal that looks something like this (just less formatted)
```sql
BEGIN;
--
-- Create model Question
--
CREATE TABLE "polls_question" (
    "id" serial NOT NULL PRIMARY KEY,
    "question_text" varchar(200) NOT NULL,
    "pub_date" timestamp with time zone NOT NULL
);
--
-- Create model Choice
--
CREATE TABLE "polls_choice" (
    "id" serial NOT NULL PRIMARY KEY,
    "choice_text" varchar(200) NOT NULL,
    "votes" integer NOT NULL,
    "question_id" integer NOT NULL
);
ALTER TABLE "polls_choice"
  ADD CONSTRAINT "polls_choice_question_id_c5b4b260_fk_polls_question_id"
    FOREIGN KEY ("question_id")
    REFERENCES "polls_question" ("id")
    DEFERRABLE INITIALLY DEFERRED;
CREATE INDEX "polls_choice_question_id_c5b4b260" ON "polls_choice" ("question_id");

COMMIT;
```
Then you can migrate if you think this looks good, and either interact with the API using the shell or the GUI
For using the python shell, you run
```bash
py manage.py shell
```
To use the GUI, you use the [django admin](https://docs.djangoproject.com/en/4.0/intro/tutorial02/#introducing-the-django-admin)

## Week Three - Handling URLs, Views and Templates
When we naviagate a website, we navigate the folders and files that the server allows us to see on the client-side. We can tell where we are based on the URL in our browser; something like "github.com/ib-bib" tells us that we navigated to the ib-bib 'directory' within GitHub.
We handle showing patterns like these in our URLs files. The example below shows a specific pattern and a few general patterns to handle
### polls/urls.py
```python
from django.urls import path
from . import views

app_name = 'polls'
urlpatterns = [
    path('', views.index, name='index'),
    path('<int:question_id>/', views.detail, name='detail'),
    path('<int:question_id>/results/', views.results, name='results'),
    path('<int:question_id>/vote/', views.vote, name='vote'),
]
```
Notice the use of 'int' there, that states that the url pattern will contain an integer which we will refer to as 'question_id'. This is very useful to be more specific in our approach to stating what are acceptable url patterns.

The 'views' that are imported at the top, are the functions that allow us to respond to these url patterns in the browser. That is, what we show the client as a result of the url pattern being selected on their browser
### polls/views.py
```python
from django.http import HttpResponse
from .models import Question
from django.shortcuts import render, get_object_or_404


def index(request):
    latest_questions_list = Question.objects.order_by('-pub_date')[:5]
    context = {'latest_questions_list': latest_questions_list, }
    return render(request, 'polls/index.html', context)


def detail(request, question_id):
    question = get_object_or_404(Question, pk=question_id)
    return render(request, 'polls/detail.html', {'question': question})
    

def results(request, question_id):
    response = "You're looking at the results of question %s."
    return HttpResponse(response % question_id)


def vote(request, question_id):
    return HttpResponse("You're voting on question %s." % question_id)
```
We notice some functions have an 'HttpResponse' as a response to the URL request. This creates a very very simple bare-bones webpage that just contains simple text that is defined in the function. In other functions there is a 'render' function that is served as a response, which returns a legitimately designed webpage, that we can customize. Moreover, we can inject some back-end code into that webpage to make it behave a certain way or display certain things, in a manner informed by data on the back-end. Such a webpage is labelled a 'template' in this context, as it's an abstract representation of what 'will be' rendered and displayed on the webpage and it's not written in traditional HTML.

Here is an example of such templates, notice the lines with curly braces and percentage signs
### polls/templates/polls/detail.html
```html
<!DOCTYPE html>
<html lang="en">
	<head>
		<meta charset="UTF-8" />
		<meta http-equiv="X-UA-Compatible" content="IE=edge" />
		<meta name="viewport" content="width=device-width, initial-scale=1.0" />
		<title>Detail</title>
	</head>
	<body>
		<h1>{{question.q_txt}}</h1>
		<ul>
			{% for choice in question.choice_set.all %} 
            {% comment %} all is interpreted as a method call () {% endcomment %}
			<li>{{choice.choice_txt}}</li>
			{% endfor %}
		</ul>
	</body>
</html>
```
We can notice the use of a for loop there, and a command to be executed at each iteration through the loop. This is more akin to programming than web design, and it allows us to abstractly (and dynamically) render however many ```<li>``` items as we need within that ```<ul>``` element. Moreover it's immediately informed by the back-end, rather than being fetched like through asynchronous javascript or something.
